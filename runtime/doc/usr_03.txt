*usr_03.txt*	Nvim

		    VIM 사용 설명서 - Bram Moolenaar 저

			     이동하기


텍스트를 삽입하거나 삭제하기 전에 커서를 올바른 위치로 이동해야 합니다. 
Vim은 커서를 위치시키기 위해 많은 명령어를 가지고 있습니다. 
이 장에서는 가장 중요한 것을 사용하는 방법을 설명합니다. 
이러한 명령 목록은 | Q_lr | 아래에 있습니다.

|03.1|	단어 이동
|03.2|	행의 시작 또는 끝으로 이동
|03.3|	캐릭터로 이동
|03.4|	괄호 매치
|03.5|	특정 라인으로 이동
|03.6|	
|03.7|	스크롤
|03.8|	간단한 검색
|03.9|	간단한 검색 패턴
|03.10|	마크 사용

    다음 장 : |usr_04.txt| 작은 변화 만들기
 이전 장 : |usr_02.txt|  Vim의 첫 번째 단계
목차 : |usr_toc.txt|

==============================================================================
*03.1*	단어 이동

커서를 한 단어 앞으로 이동하려면 "w"명령을 사용하십시오. 
대부분의 Vim 명령과 마찬가지로 숫자 접두사를 사용하여 여러 단어를 지나갈 수 있습니다. 
예를 들어, "3w"는 세 단어를 이동합니다. 
이 그림은 작동 원리를 보여줍니다.

	This is a line with example text ~
	  --->-->->----------------->
	   w  w  w    3w


"w"는 이미 단어의 시작 부분에 있는 경우 다음 단어의 시작 부분으로 이동합니다. 
"b"명령은 이전 단어의 시작 부분으로 뒤로 이동합니다.

	This is a line with example text ~
	<----<--<-<---------<---
	   b   b b    2b      b

단어의 다음 끝으로 이동하는 "e"명령과 단어의 이전 끝으로 이동하는 "ge"도 있습니다.

	This is a line with example text ~
	   <-   <--- ----->   ---->
	   ge    ge     e       e

당신이 줄의 마지막 단어에 있다면, "w"명령은 다음 줄의 첫 번째 단어로 이동합니다. 
따라서 이것을 사용하여 "l"을 사용하는 것보다 단락을 빨리 이동할 수 있습니다. 
"b"는 다른 방향으로 동일합니다.

단어는 ".", "-"또는 ")"와 같이 단어가 아닌 문자로 끝납니다. 
vim이 단어라고 생각하는 것을 바꾸려면 'iskeyword'옵션을 보십시오. 
도움말에서 직접 시도해 보면 예제가 작동하려면 'iskeyword'를 재설정해야 합니다.>
: set iskeyword &
공백으로 구분 된 단어로 이동할 수도 있습니다. 
이것은 정상적인 의미의 단어가 아니기 때문에 대문자가 사용되는 이유입니다. 
이 그림에서 볼 수 있듯이 WORD 단위로 이동하는 명령은 대문자입니다.

	       ge      b	  w				e
	       <-     <-	 --->			       --->
	This is-a line, with special/separated/words (and some more). ~
	   <----- <-----	 -------------------->	       ----->
	     gE      B			 W			 E

소문자와 대문자 명령을 혼합하여 신속하게
단락을 앞뒤로 이동하십시오.

==============================================================================
*03.2*	행의 시작 또는 끝으로 이동


"$"명령은 커서를 줄 끝으로 이동시킵니다. 키보드에있는 경우
<End> 키는 같은 일을 할 것입니다.


"^"명령은 행의 첫 번째 공백이 아닌 문자로 이동합니다. 
"0"명령 (제로)은 행의 첫 문자로 이동합니다. 
<Home> 키도 똑같습니다. 
그림에서 :

		  ^
	     <------------
	.....This is a line with example text ~
	<-----------------   --------------->
		0		   $


( "....."은 여기에서 공백을 나타냅니다)

   "$"명령은 대부분의 이동 명령과 마찬가지로 count를 받습니다. 
   그러나 라인의 끝까지 여러 번 움직이는 것은 의미가 없습니다. 
   따라서 편집기가 다른 행의 끝으로 이동합니다.
   예를 들어, "1 $"은 첫 번째 행 (사용자가 사용중인 행)의 끝으로 이동하고, "2 $"는 다음 행의 끝까지 이동합니다.
   "0"명령은 카운트 인수를 취하지 않기 때문에, "0"카운트의 일부가 될 것이기 때문이다.
   예기치 않게 "^"가 포함 된 개수를 사용해도 아무런 효과가 없습니다.

==============================================================================
*03.3*	 문자로 이동

가장 유용한 이동 명령 중 하나는 단일 문자 검색 명령입니다. 
"fx"명령은 줄에서 한 문자 x를 찾습니다. 
힌트 : "f"는 "찾기"를 의미합니다.
   예를 들어, 다음 행의 시작 부분에 있습니다. 
   당신이 human의 h로 가고 싶다고 가정 해보십시오. 
   그냥 "fh"명령을 실행하면 커서가 h 위에 위치하게됩니다.

	To err is human.  To really foul up you need a computer. ~
	---------->--------------->
	    fh		 fy

이것은 또한 "fy"명령이 정말로 단어의 끝으로 이동한다는 것을 보여줍니다.
   개수를 지정할 수 있습니다. 
   따라서 "3fl"을 사용하여 "파울"의 "l"로 이동할 수 있습니다.

	To err is human.  To really foul up you need a computer. ~
		  --------------------->
			   3fl


"F"명령은 왼쪽으로 검색합니다 :

	To err is human.  To really foul up you need a computer. ~
		  <---------------------
			    Fh

"tx"명령은 "fx"명령과 같이 작동합니다. 
단, 검색된 문자보다 한 문자 앞 당겨야 합니다. 
힌트 : "t"는 "to"을 의미합니다. 
이 명령의 역방향 버전은 "Tx"입니다.

	To err is human.  To really foul up you need a computer. ~
		   <------------  ------------->
			Th		tn

이 네 가지 명령은 ";"을 사용하여 반복 할 수 있습니다. 
"," 다른 방향으로 반복합니다. 
커서는 절대로 다른 행으로 이동하지 않습니다. 
문장이 계속되는 경우조차도.

때로는 잘못된 명령을 입력했음을 인식하기 위해서만 검색을 시작합니다. 
예를 들어 "F"를 의미하는 것을 깨닫기 위해 "f"를 입력하면 뒤로 검색 할 수 있습니다.
검색을 중단하려면 <Esc> 키를 누르십시오. 
따라서 "f <Esc>"는 중단된 순방향 검색이며 아무 것도하지 않습니다. 
참고 : <Esc>는 검색뿐만 아니라 대부분의 작업을 취소합니다.

==============================================================================
*03.4*	괄호 매치

프로그램을 작성할 때 종종 nested () 구조로 끝납니다. 
그런 다음 "%"명령은 매우 편리합니다. 
일치하는 괄호로 이동합니다. 
커서가 "("에 있으면 일치하는 ")"로 이동합니다. 
그것이 ")"이면 일치하는 "("로 이동합니다.

			    %
			 <----->
		if (a == (b * c) / d) ~
		   <---------------->
			    %

이것은 []와 {} 쌍에도 적용됩니다. 
(이것은 'matchpairs'옵션으로 정의 할 수 있습니다.)

커서가 유용한 문자 위에 있지 않으면 "%"는 앞으로 검색하여 하나를 찾습니다. 
따라서 커서가 이전 예제의 줄의 시작 부분에 있으면 "%"는 앞으로 검색하고 첫 번째 "("를 찾습니다. 
그러면 일치 항목으로 이동합니다 :

		if (a == (b * c) / d) ~
		---+---------------->
			   %

==============================================================================
*03.5*	특정 라인으로 이동

C 또는 C ++ 프로그래머라면 다음과 같은 오류 메시지에 익숙합니다.

	prog.c:33: j   undeclared (first use in this function) ~

33 행에 무엇인가를 고칠 수 있다는 것을 알려줍니다. 
33 행은 어떻게 찾을 수 있습니까? 
한 가지 방법은 "9999k"를 파일 맨 위로 이동하고 "32j"는 32 줄로 이동하는 것입니다. 
그것은 좋은 방법은 아니지만 작동합니다. 
훨씬 더 좋은 방법은 "G"명령을 사용하는 것입니다. 
count를 사용하면 주어진 라인 번호에 사용자를 위치시킵니다.
예를 들어, "33G"는 33 행에 넣습니다. 
(컴파일러의 오류 목록을 살펴 보는 더 좋은 방법은 : make, 명령에 대한 정보는 | usr_30.txt |를 참조하십시오.) 
인수가 없으면 "G"는 파일 끝에. 파일의 시작 부분으로가는 빠른 방법은 "gg"를 사용하는 것입니다. 
"1G"는 동일한 작업을 수행하지만 입력 작업이 조금 더 많습니다.

	    |	first line of a file   ^
	    |	text text text text    |
	    |	text text text text    |  gg
	7G  |	text text text text    |
	    |	text text text text
	    |	text text text text
	    V	text text text text    |
		text text text text    |  G
		text text text text    |
		last line of a file    V

한 행으로 이동하는 또 다른 방법은 "%"명령을 카운트와 함께 사용하는 것입니다. 
예를 들어, "50 %"는 파일의 중간까지 이동하고 "90 %"는 끝까지 이동합니다.

앞에서는 파일이 현재 표시되는지 여부에 관계없이 파일의 행으로 이동한다고 가정합니다. 
볼 수있는 선으로 이동하고 싶다면? 이 그림은 사용할 수있는 세 가지 명령을 보여줍니다.

			+---------------------------+
		H -->	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		M -->	| text sample text	    |
			| sample text		    |
			| text sample text	    |
			| sample text		    |
		L -->	| text sample text	    |
			+---------------------------+

힌트 : "H"는 홈, "M"은 중간, "L"은 마지막을 나타냅니다.

==============================================================================
*03.6*	 위치 확인하기

파일에있는 위치를 확인하려면 다음 세 가지가 있습니다.

1.  CTRL-G 명령을 사용하십시오. 
 다음과 같은 메시지가 나타납니다 ( 'ruler'옵션이 꺼져 있다고 가정).

	"usr_03.txt" line 233 of 650 --35%-- col 45-52 ~

    편집중인 파일의 이름, 커서가있는 행 번호, 총 행 수, 파일을 통과하는 경로의 백분율 및 커서의 열을 표시합니다. 
    때로는 분할 열 번호가 표시됩니다. 예 : "col 2-9".
    이것은 커서가 두 번째 문자에 위치함을 나타냅니다. 
    그러나 문자 1은 8 개의 공백 열을 차지하는 탭이므로 화면 열은 9입니다.

2.  'number' 옵션을 설정하십시오. 그러면 앞에 줄 번호가 표시됩니다.
    모든 행 :>

	:set number
<
   이 기능을 다시 끄려면 :>

	:set nonumber
<
    
'number'는 boolean 옵션이므로 이름 앞에 "no"를 붙이면 꺼지게 하는 효과가 있습니다. 
boolean 옵션에는 이 두 값만 있으며 켜기 또는 끄기 중 하나입니다.
       Vim에는 많은 옵션이 있습니다. 
       boolean값 외에 숫자 값과 문자열 옵션이 있는 옵션이 있습니다. 
       그들이 사용되는 곳의 예를 볼 수 있습니다.

3.  'ruler'옵션을 설정하십시오. 
   Vim 창의 오른쪽 아래 모서리에 커서 위치가 표시됩니다.>

	:set ruler

'ruler'옵션을 사용하면 공간이 많이 필요하지 않으므로 텍스트 공간을 확보 할 수 있습니다.

==============================================================================
*03.7*	스크롤

CTRL-U 명령은 텍스트 화면의 절반을 아래로 스크롤합니다.
텍스트를 보는 창을보고 창 높이의 절반만큼 이 창을 움직이는 것을 생각해보십시오. 
따라서 창은 파일에서 뒤로 이동하는 텍스트 위로 이동합니다. 
기억에 조금 문제가 있으면 걱정하지 마세요.
 대부분의 사용자는 동일한 문제가 있습니다.
   CTRL-D 명령은보기 창을 파일의 화면 절반만큼 아래로 이동시켜 텍스트를 화면 절반 위로 스크롤합니다.

				       +----------------+
				       | some text	|
				       | some text	|
				       | some text	|
	+---------------+	       | some text	|
	| some text	|  CTRL-U  --> |		|
	|		|	       | 123456		|
	| 123456	|	       +----------------+
	| 7890		|
	|		|	       +----------------+
	| example	|  CTRL-D -->  | 7890		|
	+---------------+	       |		|
				       | example	|
				       | example	|
				       | example	|
				       | example	|
				       +----------------+

한 번에 한 줄씩 스크롤하려면 CTRL-E (위로 스크롤) 및 CTRL-Y (아래로 스크롤)를 사용하십시오. 
CTRL-E를 사용하면 Extra라는 한 줄을 얻을 수 있습니다. 
(MS Windows 호환 키 매핑을 사용하는 경우 CTRL-Y는 스크롤 대신 변경 사항을 다시 실행합니다.)

전체 화면 (두 줄 제외)으로 앞으로 스크롤하려면 CTRL-F를 사용하십시오. 
다른 방법은 뒤로, CTRL-B는 사용할 명령입니다. 
다행히 CTRL-F는 Forward이고 CTRL-B는 Backward입니다. 
기억하기 쉽습니다.

일반적인 문제는 "j"로 여러 행을 이동 한 후 커서가 화면의 맨 아래에 있다는 것입니다. 
커서가 있는 줄의 문맥을 보고 싶어할수도 있습니다. 그것은 "zz"명령으로 끝났습니다.

	+------------------+		 +------------------+
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| some text	   |   zz  -->	 | line with cursor |
	| some text	   |		 | some text	    |
	| some text	   |		 | some text	    |
	| line with cursor |		 | some text	    |
	+------------------+		 +------------------+

"zt"명령은 커서 줄을 맨 위, "zb"는 맨 아래에 놓습니다. 
그곳에 몇 가지 더 많은 스크롤 명령이 있습니다. 
| Q_sc |를 참조하십시오. 
커서 주위에 항상 몇 줄의 context를 유지하려면 'scrolloff'옵션을 사용하십시오.

==============================================================================
*03.8*	간단한 검색

문자열을 검색하려면 "/ string"명령을 사용하십시오. 포함 단어를 찾으려면,
예를 들어, 다음 명령을 사용하십시오

	/include

"/"를 입력하면 커서가 콜론 명령과 같이 Vim 창의 마지막 행으로 점프한다는 것을 알 수 있습니다. 
그것이 단어를 입력하는 곳입니다. 
백 스페이스 키 (backarrow 또는 <BS>)를 눌러 수정할 수 있습니다. 
필요한 경우 <왼쪽> 및 <오른쪽> 커서 키를 사용하십시오.
   <Enter> 키를 누르면 명령이 실행됩니다.

	참조:
	문자. * [] ^ % / \? ~ $에는 특별한 의미가 있습니다. 
  검색에 사용하려면 앞에 \를 사용해야합니다. 아래를 참조하십시오.

동일한 문자열의 다음 발생을 찾으려면 "n"명령을 사용하십시오. 
이것을 사용하여 커서 뒤에 첫 번째 #include를 찾습니다.>

	/#include

그런 다음 "n"을 여러 번 입력하십시오. 
각 #include 텍스트로 이동합니다. 
원하는 일치 항목을 알고 있으면 개수를 사용할 수도 있습니다. 
따라서 "3n"은 세 번째 일치를 찾습니다. 
"/"와 함께 카운트를 사용하면 작동하지 않습니다.


"?" 명령은 "/"와 유사하지만 뒤로 검색합니다.>

	?word


"N"명령은 마지막 탐색을 반대 방향으로 반복합니다. 
따라서 "/"명령 뒤에 거꾸로 "N"을 사용하고 "?"뒤에 "N"을 사용합니다. 
앞으로 검색합니다.

무시 사례

일반적으로 당신이 원하는 것을 정확하게 입력해야합니다. 
단어의 대소 문자를 신경 쓰지 않는다면 'ignorecase'옵션을 설정하십시오.>

	:set ignorecase

"word"를 검색하면 "Word"와 "WORD"도 일치합니다. 사례를 다시 일치시키기 :>

	:set noignorecase


역사

세 가지 검색을한다고 가정 해보십시오.>

	/one
	/two
	/three

이제 <Enter>를 누르지 않고 간단한 "/"를 입력하여 검색을 시작하십시오. 
<위로> (커서 키)를 누르면 Vim은 "/ three"를 명령 행에 놓습니다. 
이 지점에서 <Enter> 키를 누르면 3이 검색됩니다. <Enter>를 누르지 않고 대신 <Up>을 누르면 Vim은 프롬프트를 "/ 2"로 변경합니다. 
<위로>를 누르면 "/ one"으로 이동합니다.
<아래로> 커서 키를 사용하여 다른 방향으로 검색 명령 내역을 이동할 수도 있습니다.

이전에 사용한 패턴이 무엇인지 알고 있고 다시 사용하려면 <Up>을 누르기 전에 해당 문자를 입력하십시오. 
앞의 예제에서 "/ o <Up>"을 입력하면 Vim은 명령 줄에 "/ one"을 입력합니다.

":"로 시작하는 명령도 기록이 있습니다. 
따라서 이전 명령을 다시 호출하고 다시 실행할 수 있습니다.
이 두 역사는 별개입니다.

텍스트에서 단어 검색하기

텍스트에서 "TheLongFunctionName"이라는 단어를 보고 다음 단어를 찾으려고 한다고 가정 해보십시오. 
"/ TheLongFunctionName"을 입력 할 수는 있지만 많은 타이핑이 필요합니다. 
그리고 실수를하면 Vim은 그것을 찾지 못할 것입니다.
   더 쉬운 방법이 있습니다 : 단어 위에 커서를 놓고 "*"명령을 사용하십시오. 
   Vim은 커서 아래에있는 단어를 잡고 검색 문자열로 사용합니다.
   "#"명령은 다른 방향으로도 동일하게 작동합니다. 
   count를 앞에 붙일 수 있습니다.
   "3 *"은 커서 아래에서 세 번째 단어를 찾습니다.


전체 단어 검색하기

"/the"를 입력하면 "there"와 일치합니다. 
"the"로 끝나는 단어 만 찾으려면 :>

	/the\>

"\>"항목은 단어 끝에 만 일치하는 특수 마커입니다.
마찬가지로 "\ <"는 단어 시작 부분에서만 일치합니다. 
따라서 단어 "the"만을 검색하려면 :>

	/\<the\>

이것은 "there"또는 "soothe"와 일치하지 않습니다. 
"*"및 "#"명령은 단어 시작 및 단어 끝 표시를 사용하여 전체 단어만 찾습니다 
(부분 단어와 일치시키기 위해 "g *"및 "g #"를 사용할 수 있음).

HIGHLIGHTING MATCHES

프로그램을 편집하는 동안 "nr"이라는 변수가 나타납니다. 
어디에서 사용했는지 확인하고 싶습니다. 
커서를 "nr"로 옮기고 "*"명령을 사용하고 "n"을 눌러 모든 일치를 따라갈 수 있습니다.

Vim은 모든 경기를 강조 표시합니다. 
이것은 명령을 입력 할 필요없이 변수가 사용되는 곳을 확인하는 아주 좋은 방법입니다.
   이 기능을 끄려면 :>

	:set nohlsearch

다음 검색 명령에 사용하려면 다시 켜야합니다.>

	:set hlsearch

강조 표시 만 제거하려면 다음 명령을 사용하십시오.>

	:nohlsearch

옵션을 재설정하지 않습니다. 
대신 강조 표시를 사용하지 않습니다. 
검색 명령을 실행하자마자 강조 표시가 다시 사용됩니다. 또한 "n"및 "N"명령.

TUNING SEARCHES

검색 작동 방식을 변경하는 몇 가지 옵션이 있습니다.
이들은 필수적인 것들입니다 :
>
	:set nowrapscan

이렇게하면 파일의 끝에서 검색이 중지됩니다. 
또는 파일의 시작 부분에서 거꾸로 검색 할 때 'wrapscan'옵션은 기본적으로 켜져 있으므로 검색은 파일의 끝 부분을 둘러 쌉니다.
>
	:set noincsearch

이렇게하면 검색을 계속 입력하는 동안 일치 항목이 표시되지 않습니다.

INTERMEZZO

이전에 언급 한 옵션 중 하나가 마음에 들면 Vim을 사용할 때마다 이 옵션을 설정하면 Vim 시작 파일에 명령을 넣을 수 있습니다. 
파일 편집 : 예 :>

	:edit ~/.config/nvim/init.vim

그런 다음 Vim에 입력 한 것처럼 명령을 사용하여 옵션을 설정하는 행을 추가하십시오. 예 :>
	Go:set hlsearch<Esc>

"G"는 파일의 끝으로 이동합니다. 
"o"는 ": set"명령을 입력하는 새 줄을 시작합니다. 
<Esc> 키를 사용하여 삽입 모드를 종료합니다. 
그런 다음 파일을 작성하십시오.>

이제 Vim을 다시 시작하면 'hlsearch'옵션이 이미 설정되어 있을 것다.

==============================================================================
*03.9*	간단한 검색 패턴

Vim 편집기는 정규 표현식을 사용하여 검색 대상을 지정합니다. 
정규 표현식은 검색 패턴을 지정하는 매우 강력하고 간단한 방법입니다.
불행하게도 정규 표현식은 약간 까다롭기 때문에 이 힘은 가격이 책정됩니다.
이 부분에서는 몇 가지 중요한 것들만 언급합니다. 
27 장 | usr_27.txt |에서 검색 패턴과 명령에 대해 자세히 설명합니다.
여기에서 전체 설명을 찾을 수 있습니다 : | pattern |

라인의 시작과 끝

^ 문자는 행의 시작과 일치합니다. 영어 (미국) 키보드에서는 6보다 위에 있습니다.
"include"패턴은 라인의 임의의 위치에있는 단어와 일치합니다. 
그러나 패턴 "^ include"는 줄의 시작 부분에 있을 때만 단어 include와 일치합니다.
   $ 문자는 줄의 끝과 일치합니다.
   따라서 "$이었다"는 말은 단어가 줄의 끝에있는 경우에만 일치합니다.

이 예제 라인에서 "the"가 "x"s와 일치하는 장소를 표시해 보겠습니다.

	the solder holding one of the chips melted and the ~
	xxx			  xxx		       xxx

"/ the $"를 사용하여 이 일치 항목을 찾습니다

	the solder holding one of the chips melted and the ~
						       xxx

그리고 "/ ^ the"와 함께 우리는 이것을 발견합니다 :
	the solder holding one of the chips melted and the ~
	xxx

"/ ^ the $"로 검색해 보면 "the"로 구성된 한 줄만 일치합니다. 
공백은 여기서 중요한 의미를 가지므로 "the"와 같이 단어 뒤에 공백이 있으면 줄이 일치하지 않습니다.

모든 단일 문자와 일치


. (점) 문자는 기존 문자와 일치합니다. 
예를 들어 패턴 "c.m"은 첫 번째 문자가 c이고 두 번째 문자가 모두이고 세 번째 문자가 m 인 문자열과 일치합니다.
예:
	We use a computer that became the cummin winter. ~
		 xxx		 xxx	  xxx

맞춤 특수 문자

실제로 도트를 일치시키려면 그 앞에 백 슬래시를 두어 특수한 의미를 피해야합니다.
   "ter."를 검색하면 다음과 같은 일치 항목을 찾을 수 있습니다.
   
	We use a computer that became the cummin winter. ~
		      xxxx			    xxxx


"ter \"검색 중. 두 번째 match만 찾습니다.

==============================================================================
*03.10*	마크 사용

"G"명령으로 점프를하면 Vim은 점프하기 전의 위치를 기억합니다. 
이 위치를 마크라고합니다. 
어디에서 왔는지 돌아가려면 다음 명령을 사용하십시오.

	``

이것은`역 따옴표 또는 열린 작은 따옴표 문자입니다. 
동일한 명령을 두 번 사용하면 다시 점프합니다. 
왜냐하면 `명령은 점프 그 자체이고 점프하기 전의 위치가 기억되기 때문입니다.

일반적으로 커서를 동일한 줄 내에서보다 멀리 이동할 수있는 명령을 수행 할 때마다 이를 점프라고 합니다. 
여기에는 "/"및 "n"검색 명령이 포함됩니다 (일치하는 항목이 얼마나 멀리 떨어져 있든 상관 없습니다). 
그러나 문자는 "fx"와 "tx"또는 단어 이동 "w"와 "e"로 검색하지 않습니다.
 또한 "j"와 "k"는 점프로 간주되지 않습니다. 카운트를 사용하여 커서를 아주 먼 곳으로 이동시킬 때도 마찬가지입니다.

``명령은 두 지점 사이를 왔다 갔다합니다. CTRL-O 명령은 이전 위치로 이동합니다 (힌트 : 이전의 경우 O). 
CTRL-I 그러면 새로운 위치로 돌아갑니다 (힌트 : 키보드의 O 옆에 있습니다).
다음 명령 순서를 고려하십시오.>

	33G
	/^The
	CTRL-O

먼저 33 행으로 이동 한 다음 "The"로 시작하는 행을 검색합니다.
그런 다음 CTRL-O를 사용하면 33 행으로 돌아갑니다. 
다른 CTRL-O을 사용하면 시작한 곳으로 다시 이동합니다.
CTRL-I를 사용하면 33 행으로 다시 이동합니다.

	     |	example text   ^	     |
	33G  |	example text   |  CTRL-O     | CTRL-I
	     |	example text   |	     |
	     V	line 33 text   ^	     V
	     |	example text   |	     |
       /^The |	example text   |  CTRL-O     | CTRL-I
	     V	There you are  |	     V
		example text

	참조:
CTRL-I는 <Tab>과 동일합니다.

": jumps"명령은 점프 한 위치 목록을 제공합니다. 
마지막으로 사용한 항목은 ">"로 표시됩니다.

이름 표시				*bookmark*

Vim을 사용하면 텍스트에 자신의 mark을 표시 할 수 있습니다. 
"ma"명령은 커서 아래의 위치를 a로 표시합니다. 
텍스트에 26 자까지 (a에서 z까지) 표시 할 수 있습니다. 
당신은 그들을 볼 수 없으며, 그것은 Vim이 기억하는 위치에 불과합니다. 
표시로 가려면`{mark} '명령을 사용하십시오. 
여기서 {mark}는 표시 문자입니다. 
따라서 마크로 이동하려면 :
>
	`a

'표시 (작은 따옴표 또는 아포스트로피) 명령은 표시가 있는 행의 시작 부분으로 이동합니다. 
이것은 마크된 컬럼으로 이동시키는 `mark 명령어 와는 다르다.

이 표시는 파일에서 두 개의 관련 부분을 작업 할 때 매우 유용 할 수 있습니다. 
파일의 끝 부분에있는 일부 텍스트를 보고있는 동안, 파일의 시작 부분 근처에 텍스트가 있는 것으로 가정하십시오.
   시작시 텍스트로 이동하여 s (시작) 표시를 그곳에 놓습니다.

	ms

그런 다음 작업 할 텍스트로 이동하여 거기에 e (끝) 표시를 하십시오.>

	me

이제 이동할 수 있으며, 파일의 시작 부분을보고 싶을 때 이 부분을 사용하여 이동할 수 있습니다.>

	's

그런 다음 ''을 사용하여 현재 위치로 돌아갈 수도 있고, 마지막에 작업했던 텍스트로 이동할 수도 있습니다.
   시작과 종료를 위해 s를 사용하는 것에 특별한 것은 없지만 기억하기 쉽습니다.

이 명령을 사용하여 마크 목록을 얻을 수 있습니다 :>

	:marks

몇 가지 특별한 표시가 있습니다. 여기에는 다음이 포함됩니다.

	'	점프를하기 전의 커서 위치
	"	마지막으로 파일을 편집 할 때의 커서 위치
	[	마지막 변경 시작
	]	최종 변경의 끝

==============================================================================

다음 장 : |usr_04.txt|  작은 변화 만들기

저작권 :|manual-copyright|을 참조하십시오.  vim:tw=78:ts=8:ft=help:norl:
