* usr_10.txt * Nvim

VIM 사용 설명서 - Bram Moolenaar 저

큰 변화


4장에서는 작은 변화를 일으키는 몇 가지 방법을 설명했다. 
이 장은 반복되거나 많은 양의 텍스트에 영향을 줄 수 있는 변경 사항을 작성합니다. 
비주얼 모드는 텍스트 블록으로 다양한 작업을 수행 할 수 있습니다. 
정말 복잡한 일을하기위해 외부 프로그램을 사용하십시오.

| 10.1 | 기록 및 재생 명령
| 10.2 | 치환
| 10.3 | 명령 범위
| 10.4 | 전역 명령
| 10.5 | 비주얼 블록 모드
| 10.6 | 파일의 일부 읽기 및 쓰기
| 10.7 | 텍스트 서식 지정
| 10.8 | 케이스 변경
| 10.9 | 외부 프로그램 사용

     다음 장 : | usr_11.txt | 충돌에서 복구
 이전 장 : | usr_09.txt | GUI 사용
목차 : | usr_toc.txt |

========================================================================================================================================================================
* 10.1 * 기록 및 재생 명령

"." 명령은 앞의 변경 사항을 반복합니다. 
그러나 단일 변경보다 복잡한 작업을 원할 경우 어떻게 해야 합니까? 
그것이 명령 기록이 들어오는 곳입니다. 다음 세 단계가 있습니다.

1. "q {register}"명령은 키 스트로크를 {register}라는 레지스터에 기록하기 시작합니다. 레지스터 이름은 a와 z 사이 여야합니다.
2. 명령을 입력하십시오.
3. 녹음을 끝내려면 q를 누릅니다 (추가 문자 없음).

이제 "@ {register}"명령을 입력하여 매크로를 실행할 수 있습니다.

실제로 이러한 명령을 사용하는 방법을 살펴보십시오. 다음과 같은 파일 이름 목록이 있습니다.

stdio.h ~
fcntl.h ~
unistd.h ~
stdlib.h ~

그리고 당신이 원하는 것은 다음과 같습니다 :

#include "stdio.h"~
#include "fcntl.h"~
#include "unistd.h"~
#include "stdlib.h"~

첫 번째 줄의 첫 번째 문자로 이동하여 시작합니다. 
다음 명령을 실행합니다 :

매크로에 a 기록을 시작하십시오.
^ 줄의 처음으로 이동하십시오.
i # 처음에 "<Esc> 문자열 #include"를 포함시킵니다.
줄의.
$ 줄 끝으로 이동하십시오.
a "<Esc> 문자 큰 따옴표 (")를 추가하십시오
줄 끝까지.
j 다음 줄로 가십시오.
q 매크로 기록을 중지하십시오.

이제 작업을 한 번 했으므로 "@a" 명령을 세 번 입력하여 변경 사항을 반복할 수 있습니다. 
"@a"명령 앞에는 매크로가 해당 횟수만큼 실행되게 하는 카운트가 있을 수 있습니다. 
이 경우 다음을 입력합니다.>

3 @ a

이동 및 실행

여러 곳에서 변경하고 싶은 라인이 있을 수 있습니다. 
각 위치로 커서를 이동하고 "@a"명령을 사용하십시오. 
한번 해봤으면 "@@"로 다시 할 수 있습니다. 
그건 좀 더 쉽게 입력 할 수 있습니다. 
레지스터 b를 "@b"로 실행하면 다음 "@@"가 레지스터 b를 사용합니다. 
"."를 사용하여 재생 방법을 비교하면 몇 가지 차이점이 있습니다. 
가장 먼저, "." 하나의 변경 만 반복 할 수 있습니다. 
위의 예에서 볼 수 있듯이 "@a"는 몇 가지 변경 작업을 수행 할 수 있습니다. 
둘째, "." 마지막 변경 사항 만 기억할 수 있습니다. 
레지스터를 실행하면 변경 사항을 적용한 다음 "@a"를 사용하여 기록 된 명령을 재생할 수 있습니다. 
마지막으로 26 개의 다른 레지스터를 사용할 수 있습니다. 
따라서 실행할 26 가지 명령 시퀀스를 기억할 수 있습니다.

등록기 사용

녹음에 사용되는 레지스터는 yank 및 delete 명령에 사용한 레지스터와 동일합니다. 
이렇게하면 기록을 다른 명령과 혼합하여 레지스터를 조작 할 수 있습니다.
   레지스터 n에 몇 가지 명령을 기록했다고 가정 해보십시오. 
   "@n"으로 이것을 실행하면 잘못된 것을 알게됩니다. 
   다시 녹음을 시도 할 수는 있지만 다른 실수를 저 지르게 될 것입니다. 
   대신 이 속임수를 사용하십시오.

G 파일 끝으로 가십시오.
o <Esc> 빈 줄을 만듭니다.
"np n 레지스터의 텍스트를 넣으십시오. 이제 보았습니다.
파일에 텍스트로 입력 한 명령.
{edits} 잘못된 명령을 변경하십시오. 이것은
텍스트 편집과 마찬가지입니다.
0 행의 시작 부분으로 이동하십시오.
"ny $ n에 수정 된 명령을 씁니다.
레지스터.
dd 스크래치 라인을 삭제합니다.

이제 "@n"을 사용하여 수정 된 명령을 실행할 수 있습니다. 
기록 된 명령에 줄 바꿈이 포함 된 경우 모든 줄을 포함하도록 예제의 마지막 두 항목을 조정하십시오.

등록자에게 첨부하기

지금까지는 레지스터 이름에 소문자를 사용했습니다. 
레지스터에 추가하려면 대문자를 사용하십시오.
c를 등록 할 단어를 변경하라는 명령을 기록했다고 가정해보십시오. 
제대로 작동하지만 변경하려는 다음 단어에 대한 검색을 추가하려고 합니다. 
이 작업은 다음을 통해 수행 할 수 있습니다.>

qC / 단어 <Enter> q

"qC"로 시작하면 c 레지스터에 기록하고 추가합니다. 
따라서 대문자 레지스터 이름에 쓰는 것은 동일한 문자로 레지스터에 추가한다는 것을 의미하지만 소문자입니다.

이 작업은 녹음 및 yank 및 delete 명령과 함께 작동합니다. 
예를 들어 레지스터에 일련의 줄을 수집하려고합니다.
첫 번째 줄을 다음과 같이 처리하십시오.>

"찬성

이제 두 번째 줄로 이동하여 다음을 입력하십시오.>

"찬성

모든 행에 대해 이 명령을 반복하십시오. 
이제 레지스터에는 모든 라인이 포함 된 순서대로 포함됩니다.

==============================================================================
* 10.2 * 대체 * 찾기 - 바꾸기 *

": substitute"명령을 사용하면 전체 행 범위에서 문자열 바꾸기를 수행 할 수 있습니다. 
이 명령의 일반적인 형식은 다음과 같습니다.>

: [범위] substitute / from / to / [플래그]

이 명령은 [범위]로 지정된 행에서 "시작" 문자열을 "종료" 문자열로 변경합니다. 
예를 들어, 다음 명령을 사용하여 모든 줄에서 "교수"를 "교사"로 변경할 수 있습니다.>

: % 대체 / 교수 / 교사 /
<
참조 :
": substitute"명령은 거의 철자가 거의 쓰이지 않습니다.
대부분의 경우 사람들은 축약 된 버전 ": s"를 사용합니다. 
여기에서 약어가 사용됩니다.

명령 앞에있는 "%"는 명령이 모든 행에서 작동함을 지정합니다. 
범위가 없으면 ": s"는 현재 행에서만 작동합니다. 
다음 섹션 | 10.3 |에서 범위에 대해 자세히 설명합니다.

기본적으로 ": substitute"명령은 각 줄에서 첫 번째 항목만 변경합니다. 
예를 들어 앞의 명령은 다음 행을 변경합니다.

Smith 교수는 오늘 존슨 교수를 비판했다. ~ ~

에:

스미스 선생님은 오늘 존슨 교수를 비난했다. ~ ~

행의 모든 발생을 변경하려면 g (전역) 플래그를 추가해야합니다.
명령 :>

: % s / 교수 / 선생님 / g

결과는 다음과 같습니다 (원래 행으로 시작).

스미스 선생님은 오늘 존슨 선생님을 비판했습니다. ~ ~

다른 플래그는 ": substitute"명령이 변경된 마지막 행을 인쇄하도록하는 p (print)를 포함합니다. 
c (confirm) 플래그는 ": substitute"에게 각 대체를 수행하기 전에 확인을 요청합니다. 
다음을 입력하십시오 :>

: % s / 교수 / 선생님 / c

Vim은 "교수"의 첫 번째 발생을 찾아 변경하려는 텍스트를 표시합니다. 
다음 프롬프트가 표시됩니다.>

교사 (y / n / a / q / l / ^ E / ^ Y)로 대체 하시겠습니까?

이 시점에서 다음 대답 중 하나를 입력해야합니다.

y 예. 이 변경하십시오.
아니오. 이 경기를 건너 뜁니다.
모두; 이 변화와 그 밖의 모든 것들을
추가 확인.
q 종료; 더 이상 변경하지 마십시오.
마지막; 이 변경을하고 종료하십시오.
CTRL-E 한 줄 위로 텍스트를 스크롤하십시오.
CTRL-Y 텍스트를 한 줄 아래로 스크롤합니다.


substitute 명령의 "from"부분은 실제로 패턴입니다. 
검색 명령에 사용 된 것과 같은 종류입니다. 
예를 들어이 명령은 줄 시작 부분에 "the"를 대문자로 바꿉니다.>

: s / ^ the / these /

슬래시가 포함 된 "시작" 또는 "끝" 부분으로 바꾸려면 앞에 슬래시를 넣어야합니다. 
더 간단한 방법은 슬래시 대신 다른 문자를 사용하는 것입니다. 더하기, 예를 들면 :>

: s + 1 / 2 + 1 또는 2 +
==============================================================================
* 10.3 * 명령 범위

": substitute"명령 및 기타 많은 : 명령을 선택 행에 적용할 수 있습니다. 이를 범위라고 합니다.
   범위의 간단한 형식은 {number}, {number}입니다. 예 :>

: 1,5s / this / that / g

1 ~ 5 행에서 대체 명령을 실행합니다. 
5 행이 포함됩니다. 범위는 항상 명령 앞에 놓입니다.

하나의 특정 번호를 사용하여 하나의 특정 회선을 지정할 수 있습니다.>

: 54 대 / 대통령 / 바보 /

범위를 지정하지 않으면 일부 명령이 전체 파일에서 작동합니다. 
줄에서 작업하게하려면 "." 주소가 사용됩니다. 
": write"명령은 그런 식으로 작동합니다. 
범위가 없으면 전체 파일을 씁니다. 쓰기 위해서
현재 줄만 파일에 저장 :>

: .write otherfile

첫 번째 줄에는 항상 첫 번째 줄이 있습니다. 
마지막 줄 어때? 이 경우 "$"문자가 사용됩니다. 예를 들어,
끝까지 커서를 이동하십시오.>

:., $ s / 예 / 아니오 /

이전에 사용한 "%"범위는 실제로 첫 번째 줄에서 마지막 줄까지 "1, $"이라고 말하는 짧은 방법입니다.


패턴을 범위로 사용하기

책에서 장을 편집하고 "회색"의 모든 항목을 "회색"으로 바꾸고싶다고 가정 해보십시오. 
그러나이 장에서만, 다음 장에서는 그렇지 않습니다.
하나. 챕터 경계 만 첫 번째 열에 "챕터"라는 단어가 있다는 것을 알고 있습니다. 이 명령은 다음과 같이 작동합니다.>

:? ^ 장?, / ^ 장 / s = 회색 = 회색 = g

검색 패턴이 두 번 사용 된 것을 볼 수 있습니다. 
첫 번째 "? ^ 장?" 이 패턴과 일치하는 현재 위치 위의 선을 찾습니다. 
따라서? 패턴? 범위는 뒤로 검색하는 데 사용됩니다. 마찬가지로 "/ ^ Chapter /"는 검색에 사용됩니다.
다음 장의 시작을 위해 앞으로 나아가십시오.
슬래시와의 혼동을 피하기 위해 여기서 "="문자가 대체 명령에 사용되었습니다. 
슬래시 또는 다른 캐릭터가 잘 작동했을 것입니다.


추가 및 제출

위의 명령에 약간의 오류가 있습니다 : 
다음 챕터의 제목에 "회색"이 포함 된 경우 대체됩니다. 
어쩌면 그것이 네가 원했던 것이지만, 그렇지 않았다면? 그런 다음 오프셋을 지정할 수 있습니다.
패턴을 검색하고 위의 선을 사용하려면 :>

/ 장 / -1

1 대신에 숫자를 사용할 수 있습니다. 일치하는 항목 아래의 두 번째 줄을 처리하려면 :>

/ 장 / + 2

범위 내의 다른 항목에도 오프셋을 사용할 수 있습니다. 이거 봐요
하나 :>

:. + 3, $ - 5

이것은 커서 아래 세 줄에서 시작하여 파일의 마지막 줄 앞에있는 다섯 줄을 끝내는 범위를 지정합니다.
 
마크 사용

특정 위치의 줄 번호를 알아 내고 범위를 기억하고 입력하는 대신 자국을 사용할 수 있습니다.
   예를 들어, "mt"를 사용하여 영역의 상단을 표시하고 "mb"를 사용하여 하단을 표시하십시오. 
   그런 다음이 범위를 사용하여 표시 사이의 선 (표시가있는 선 포함)을 지정할 수 있습니다.>

:'결핵


시각 모드 및 범위

비주얼 모드로 텍스트를 선택할 수 있습니다. ":"를 눌러 콜론 명령을 시작하면 다음과 같이 표시됩니다.>

: '<,'>

이제 명령을 입력하면 시각적으로 선택된 선 범위에 적용됩니다.

참조 :
비주얼 모드를 사용하여 행의 일부를 선택하거나 CTRL-V를 사용하여 텍스트 블록을 선택하면 
콜론 명령이 전체 행에 계속 적용됩니다. 이것은 Vim의 차후 버전에서 바뀔 수있다.

'<와'>는 실제로 Visualselection의 시작과 끝 부분에 위치한 표시입니다. 
마크는 다른 시각적 선택이 이루어질 때까지 그들의 위치에 남아 있습니다. 
따라서 "<"명령을 사용하여 비주얼 영역이 시작된 위치로 이동할 수 있습니다. 
그리고 다른 항목과 마크를 혼합 할 수 있습니다 :>

: '>, $

이것은 비주얼 영역의 끝에서 파일의 끝까지의 라인을 처리합니다.


많은 수의 라인

변경할 행 수를 알면 번호를 입력 한 다음 ":"을 입력 할 수 있습니다. 
예를 들어, "5 :"를 입력하면 다음과 같이 표시됩니다.>

:.,. + 4

이제 사용할 명령을 입력 할 수 있습니다. 
범위 "."를 사용합니다.
(현재 줄)을 ". + 4"(4 줄 씩)까지 줄입니다. 
따라서 그것은 다섯 줄에 걸쳐 있습니다.

==============================================================================
* 10.4 * 글로벌 명령

": global"명령은 Vim의보다 강력한 기능 중 하나입니다. 패턴 일치를 찾고 거기에서 명령을 실행할 수 있습니다. 일반적인 형식은 다음과 같습니다.>

: [범위] 전역 / {패턴} / {명령}

이는 ": substitute"명령과 유사합니다. 그러나 일치 된 텍스트를 다른 텍스트로 바꾸는 대신 {command} 명령이 실행됩니다.

노트 :
": global"에 대해 실행 된 명령은 콜론으로 시작하는 명령이어야합니다. 일반 모드 명령은 직접 사용할 수 없습니다. | : 정상 | 명령으로이 작업을 수행 할 수 있습니다.

"foobar"를 "barfoo"로 변경하려고하지만 C ++ 스타일 주석으로 만 변경하려고한다고 가정합니다. 이 주석은 "//"로 시작합니다. 이 명령을 사용하십시오 :>

: g + // + s / foobar / barfoo / g

이것은 ": g"로 시작합니다. ": s"가 ": substitute"의 줄임말처럼 ": global"의 줄임말입니다. 그런 다음 더하기 문자로 묶인 패턴. 이후
우리가 찾고있는 패턴은 슬래시를 포함하고 있습니다.이 패턴은 플러스 문자를 사용하여 패턴을 분리합니다. 다음은 "foobar"를 "barfoo"로 변경하는 대체 명령입니다.
   전역 명령의 기본 범위는 전체 파일입니다. 따라서이 예제에서는 범위가 지정되지 않았습니다. 이는 ": substitute"와는 다른데, 범위가없는 한 줄에서 작동합니다.
   이 명령은 "//"이 줄의 중간에 나타나는 줄과 일치하기 때문에 명령이 완벽하지 않으며 "//"앞에 대체가 수행됩니다.

": substitute"와 마찬가지로 모든 패턴을 사용할 수 있습니다. 복잡한 패턴을 나중에 배우면 여기에서 사용할 수 있습니다.

======================================================================================================================================================== ================
* 10.5 * 비주얼 블록 모드

CTRL-V를 사용하면 직사각형 영역의 텍스트를 선택할 수 있습니다. 텍스트 블록과 관련하여 특별한 작업을 수행하는 몇 가지 명령이 있습니다.

비주얼 블록 모드에서 "$"명령을 사용하는 것에 대해 특별한 것이 있습니다.
마지막 모션 명령이 "$"인 경우, 비주얼 선택의 모든 라인은 커서가있는 라인이 더 짧은 경우에도 라인 끝까지 확장됩니다. 커서를 수평으로 움직이는 동작 명령을 사용해야만 효과가 유지됩니다. 따라서 "j"는 그것을 유지하고, "h"는 그것을 멈추게합니다.

삽입 텍스트

"I {string} <Esc>"명령은 시각적 블록 바로 왼쪽의 각 행에 {string} 텍스트를 삽입합니다. Ctrl + V를 눌러 시각 차단 모드로 들어갑니다. 이제 커서를 움직여 블록을 정의하십시오. 다음에는 I를 입력하여 삽입 모드로 들어가고 삽입 할 텍스트를 입력하십시오. 입력 할 때 첫 줄에만 텍스트가 나타납니다.
   <Esc>를 눌러 삽입을 끝내면 텍스트가 마술처럼 시각적 선택에 포함 된 나머지 줄에 삽입됩니다. 예:

1 ~
2 ~
3 ~
4 ~

커서를 "one"의 "o"에 놓고 CTRL-V를 누릅니다. "3j"를 "4"로 낮추십시오. 이제 네 줄에 걸친 블록 선택이 있습니다. 지금 입력 :>

이마 인. <Esc>

결과:

main.one ~을 포함하십시오.
main.two ~를 포함하십시오.
main.three ~
main.four ~를 포함하십시오.

블록이 블록으로 확장되지 않는 짧은 행에 걸쳐 있으면 해당 행에 텍스트가 삽입되지 않습니다. 
예를 들어 비주얼 블록을
이 텍스트의 첫 번째 줄과 마지막 줄에 "long"이라는 단어가 포함되어 있으므로 
두 번째 줄에서 선택한 텍스트가 없습니다.

이것은 긴 줄 ~
짧은 ~
다른 긴 줄 ~

^^^^ 선택한 블록

이제 "Ivery <Esc>"명령을 사용하십시오. 결과는 다음과 같습니다.

이것은 매우 긴 줄 ~
짧은 ~
다른 아주 긴 줄 ~

짧은 줄에는 텍스트가 삽입되지 않았습니다.

삽입 한 문자열에 개행 문자가 들어 있으면 "I"는 일반 삽입 명령과 같은 
역할을 하며 블록의 첫 번째 행에만 영향을 미칩니다.

"A"명령은 블록의 오른쪽 뒤에 추가된다는 점을 제외하고는 동일한 방식으로 작동합니다. 
그리고 짧은 줄에 텍스트를 삽입합니다.
따라서 짧은 줄에 텍스트를 추가할지 여부를 선택할 수 있습니다.
   "A"에는 특별한 경우가 하나 있습니다. 
   시각적 블록을 선택한 다음 "$"를 사용하여 블록을 각 행의 끝까지 확장하십시오. 
   이제 "A"를 사용하면 각 줄의 끝에 텍스트를 추가합니다.
   위에 나온 예제를 사용하고 "$ A XXX <Esc>"라고 입력하면
이 결과 :

이것은 긴 줄 XXX ~
짧은 XXX ~
다른 긴 줄 XXX ~

이것은 실제로 "$"명령을 사용해야합니다. Vim은 그것이 사용 된 것을 기억합니다. 
다른 이동 명령으로 커서를 가장 긴 행의 끝으로 이동하여 동일한 선택을하는 것은 동일한 결과를 갖지 않습니다.


텍스트 변경하기

시각적 블록 "c"명령은 블록을 삭제 한 다음 문자열을 입력 할 수 있도록 삽입 모드로 전환합니다. 문자열이 블록의 각 행에 삽입됩니다.
   위와 같이 "긴"단어를 선택하고 "c_LONG_ <Esc>"를 입력하면 다음과 같이됩니다.

이것은 _LONG_ 라인입니다 ~
짧은 ~
기타 _LONG_ 줄 ~

"I"처럼 짧은 줄은 바뀌지 않습니다. 또한 새 텍스트에 개행을 입력 할 수도 없습니다.

"C"명령은 블록의 왼쪽 가장자리에서 줄 끝까지 텍스트를 삭제합니다. 그런 다음 삽입 모드로 전환하여 각 행의 끝에 추가되는 문자열을 입력 할 수 있습니다.
   같은 텍스트로 다시 시작하고 "Cnew text <Esc>"를 입력하면 다음과 같은 결과가 나타납니다.

이것은 새로운 텍스트입니다 ~
짧은 ~
다른 새 텍스트 ~

"긴"단어 만 선택 되었더라도 그 뒤에 나오는 텍스트는 삭제됩니다. 따라서 시각적 블록의 왼쪽 가장자리 위치 만 중요합니다.
   다시 블록에 도달하지 않는 짧은 선은
 xcluded.

블록의 문자를 변경하는 다른 명령 :

~ 스왑 케이스 (a -> A 및 A -> a)
U 대문자 (a -> A 및 A -> A)
u 소문자 (a -> a 및 a -> a)


문자로 채우기

한 문자로 전체 블록을 채우려면 "r"명령을 사용하십시오. 다시 위에서 같은 예제 텍스트로 시작한 다음 "rx"를 입력하십시오.

이것은 xxxx 라인 ~
짧은 ~
다른 xxxx 줄 ~


노트 :
블록의 줄 끝을 넘어 문자를 포함 시키려면 25 장의 'virtualedit'기능을 확인하십시오.


이동

">"명령은 선택한 텍스트를 공백을 삽입하는 오른쪽 한 시프트 양으로 이동시킵니다. 
이 시프트의 시작점은 시각적 블록의 왼쪽 가장자리입니다.
   동일한 예제를 다시 사용하면 ">"가 다음 결과를 제공합니다.

이것은 긴 줄 ~
짧은 ~
다른 긴 줄 ~

이동량은 'shiftwidth'옵션으로 지정됩니다. 4 개의 공백을 사용하도록 변경하려면 :>

: shiftwidth = 4 설정

"<"명령은 블록의 왼쪽 가장자리에있는 하나의 쉬프트 양의 공백을 제거합니다. 
이 명령은 텍스트의 양에 의해 제한됩니다. 
사용 가능한 공백의 이동 크기보다 작 으면 가능한 한 제거합니다.


조닝 라인

"J"명령은 선택된 모든 행을 하나의 행으로 결합합니다.
따라서 줄 바꿈이 제거됩니다. 사실, 줄 바꿈, 선행 공백 및 후행 공백은 하나의 공백으로 대체됩니다.
줄 바꿈 뒤에 두 개의 공백이 사용됩니다 ( 'joinspaces'옵션을 사용하여 변경할 수 있음).
   지금 익숙해 진 예제를 사용합시다. "J"명령 사용 결과 :

이것은 긴 줄을 짧게한다. 다른 줄을 길게 ~

"J"명령에는 블록 단위 선택이 필요하지 않습니다. 
"v"및 "V"선택과 정확히 같은 방식으로 작동합니다.

공백을 변경하지 않으려면 "gJ"명령을 사용하십시오.

======================================================================================================================================================== ================
* 10.6 * 파일의 읽기와 쓰기

전자 메일 메시지를 작성할 때 다른 파일을 포함 할 수 있습니다.
이것은 ": read {filename}"명령으로 수행 할 수 있습니다. 파일 텍스트는 커서 줄 아래에 놓입니다.
   이 텍스트로 시작 :

하이 존, ~
다음은 버그를 수정 한 diff입니다. ~
안녕, 피에르. ~ ~

커서를 두 번째 줄로 이동하고 다음을 입력하십시오.>

: 패치 읽기

이 결과와 함께 "patch"라는 파일이 삽입됩니다.

하이 존, ~
다음은 버그를 수정 한 diff입니다. ~
2c2 ~
<for (i = 0; i <= length; ++ i) ~
--- ~
> for (i = 0; i <길이; ++ i) ~
안녕, 피에르. ~ ~

": read"명령은 범위를 받아들입니다. 파일은이 범위의 마지막 행 번호 아래에 놓입니다. 따라서 ": $ r patch"는 끝에 "patch"파일을 추가합니다.
파일.
   첫 번째 줄 위의 파일을 읽으려면 어떻게 해야 합니까? 행 번호 0으로 이 작업을 수행 할 수 있습니다. 
   이 행은 실제로 존재하지 않으므로 대부분의 명령에 이 행을 사용할 때 오류 메시지가 표시됩니다. 
   그러나 이 명령은 허용됩니다.
>
: 0read 패치

파일 "patch"는 파일의 첫 번째 줄 위에 놓입니다.


다양한 범위의 글쓰기

다양한 행을 파일에 쓰려면 ": write"명령을 사용할 수 있습니다.
범위가 없으면 전체 파일을 씁니다. 범위를 지정하면 지정된 행만 기록됩니다.>

: $ 템포 쓰기

이것은 커서에서 파일의 끝 부분이 "템포"파일에 기록 될 때까지 줄을 씁니다. 
이 파일이 이미 존재하면 오류 메시지가 나타납니다. 
Vim은 실수로 기존 파일을 덮어 쓰지 않도록 보호합니다. 
파일을 덮어 쓰려는 작업을 알고 있다면! :>

:., $ write! 속도

조심해! 공백없이 즉시 ": write"명령을 따라야합니다. 
그렇지 않으면 필터 명령이됩니다.이 명령은이 장의 뒷부분에서 설명합니다.


파일에 추가하기

이 장의 첫 번째 절에서는 레지스터에 여러 행을 수집하는 방법에 대해 설명했습니다. 
파일에서 행을 수집하는 경우에도 동일한 작업을 수행 할 수 있습니다.
이 명령으로 첫 번째 행을 작성하십시오.>

: .write 컬렉션

이제 수집 할 두 번째 줄로 커서를 이동하고 다음을 입력하십시오.>

: .write >> 컬렉션

">>"는 Vim에 "콜렉션"파일이 새로운 파일로 쓰여지 지 않는다는 것을 알려주지 만, 그 줄은 마지막에 추가되어야합니다. 
원하는만큼 반복 할 수 있습니다.

======================================================================================================================================================== ================
* 10.7 * 텍스트 서식 지정하기

일반 텍스트를 입력 할 때 각 줄의 길이가 자동으로 창에 맞게 조정되면 좋습니다.
텍스트를 삽입하는 동안이 작업을 수행하려면 'textwidth'옵션을 설정하십시오.>

: set textwidth = 78

예제 vimrc 파일에서이 명령이 모든 텍스트 파일에 사용되었음을 기억할 것입니다. 
따라서 vimrc 파일을 사용하고 있다면 이미 사용하고있는 것입니다. 'textwidth'의 현재 값을 확인하려면 :>

: textwidth 설정

이제 줄은 최대 78 자까지만 분리됩니다. 
그러나 라인의 중간에 텍스트를 삽입하거나 몇 단어를 지우면 Vim이 텍스트를 자동으로 다시 포맷하지 않으므로 라인이 너무 길거나 짧아집니다.
Vim에게 현재 단락의 서식을 지정하게하려면 :

gqap

이것은 연산자 인 "gq"명령으로 시작됩니다.
다음은 "단락"을 나타내는 텍스트 객체 인 "ap"입니다. 
단락은 다음 단락과 빈 줄로 구분됩니다.

노트 :
공백을 포함하는 빈 줄은 단락을 구분하지 않습니다. 
이것은주의하기 어렵다!

"ap"대신 모션 또는 텍스트 객체를 사용할 수 있습니다.
단락이 올바르게 분리되어 있으면이 명령을 사용하여 전체 파일을 포맷 할 수 있습니다.>

gggqG

"gg"는 첫 번째 행으로 이동하고 "gq"는 형식 연산자이며 "G"는 마지막 행으로 이동하는 동작입니다.

단락이 명확하게 정의되지 않은 경우 수동으로 선택하는 선의 서식을 지정할 수 있습니다. 
커서를 포맷하려는 첫 번째 줄로 이동하십시오.
"gqj"명령으로 시작하십시오. 이렇게하면 현재 행과 그 아래에있는 행의 형식이 지정됩니다. 
첫 번째 줄이 짧으면 다음 줄의 단어가 추가됩니다.
길이가 너무 길면 단어가 다음 줄로 이동합니다. 커서가 두 번째 줄로 이동합니다. 
이제 "."을 사용할 수 있습니다. 
명령을 반복하십시오. 서식을 지정할 텍스트의 끝에 올 때까지이 작업을 계속하십시오.

======================================================================================================================================================== ================
* 10.8 * 대소 문자 바꾸기

섹션 헤더가 소문자 인 텍스트가 있습니다. "섹션"이라는 단어를 모두 대문자로 만들고 싶습니다. "gU"연산자로이를 수행하십시오. 첫 번째 열에서 커서로 시작하십시오.>

괴로움
<섹션 헤더 ----> SECTION 헤더

"gu"연산자는 정확히 반대입니다.>

guw
<SECTION header ----> 섹션 헤더

또한 "g ~"를 사용하여 대소 문자를 바꿀 수 있습니다. 
이 모든 것은 연산자이며 따라서 모든 모션 명령, 텍스트 객체 및 비주얼 모드로 작업합니다.
   라인에서 작업자가 작업을 수행하도록하려면 두 배로하십시오. 
   삭제 연산자는 "d"이므로 "dd"를 사용하는 행을 삭제합니다. 
   비슷하게 "gugu"는 전체 줄을 소문자로 만듭니다. 이것은 "guu"로 단축 될 수 있습니다. 
   "gUgU"는 "gUU"로, "g ~ g ~"는 "g ~ ~"로 단축됩니다. 예 :>

g ~~
<여자애들은 재미 있어요 ----> 어떤 여자애들은 재미 있어요 ~

======================================================================================================================================================== ================
* 10.9 * 외부 프로그램 사용

빔은 매우 강력한 명령을 가지고 있으며, 무엇이든 할 수 있습니다. 
그러나 외부 명령이 더 훌륭하게 또는 더 빨리 할 수 있는 무언가가 있을 수 있습니다.
   "! {motion} {program}"명령은 텍스트 블록을 가져 와서 외부 프로그램을 통해 필터링합니다. 
   즉, {program}에 의해 표현 된 시스템 명령을 실행하여 {motion}로 표시된 텍스트 블록을 입력으로 제공합니다.
   이 명령의 출력은 선택한 블록을 대체합니다.
   Unix 필터에 익숙하지 않은 사람이라면이 내용을 간략하게 요약하기 때문에 예제를 살펴보십시오. 
   sort 명령은 파일을 정렬합니다. 
   다음 명령을 실행하면 정렬되지 않은 파일 input.txt가 정렬되고
output.txt. 이것은 유닉스와 윈도우에서 모두 작동합니다. >

정렬 <input.txt> output.txt

이제 Vim에서 똑같은 작업을하십시오. 
파일의 1 ~ 5 행을 정렬하려고합니다.
커서를 1 행에두면됩니다. 
다음 명령을 실행하십시오.>

! 5G

"!" Vim에게 당신이 필터 연산을 수행하고 있다고 알려준다.
Vim 편집기는 파일의 어떤 부분을 필터링 할지를 나타내는 동작 명령을 따라야한다. 
"5G"명령은 Vim에게 5 행으로 가도록 지시하므로 이제는 1 행 (현재 행)을 5 행으로 필터링하는 것임을 알게됩니다.
   필터링을 예상하여 커서가 화면의 맨 아래로 떨어지고! 프롬프트가 표시됩니다. 
   이제 필터 프로그램의 이름을 입력 할 수 있습니다.
   이 경우에는 "sort"입니다. 
   따라서 전체 명령은 다음과 같습니다.>

! 5Gsort <Enter>

결과적으로 정렬 프로그램은 처음 5 행에서 실행됩니다. 출력
이 줄을 프로그램의 대체합니다.

라인 55 라인 11
33 행 22
11 번줄 → 33 번줄
라인 22 라인 44
라인 44 라인 55
마지막 줄 마지막 줄

"!!" 명령은 필터를 통해 현재 줄을 필터링합니다. 
Unix에서 "date"명령은 현재 시간과 날짜를 인쇄합니다. 
"!! date <Enter>"는 현재 행을 "date"의 출력으로 바꿉니다. 
이것은 파일에 타임 스탬프를 추가 할 때 유용합니다.


그것이 작동하지 않는 경우

셸을 시작하고 텍스트를 보내고 출력을 캡처하려면 Vim이 셸의 작동 방식을 알고 있어야 합니다. 
필터링 문제가 발생하면 다음 옵션 값을 확인하십시오.

'shell'은 빔이 실행하는 데 사용하는 프로그램을 지정합니다.
외부 프로그램.
'shellcmdflag'인수는 쉘에 명령을 전달합니다.
명령을 사용할 때 사용되는 'shellquote'따옴표
'shellxquote'따옴표는 명령과 리디렉션에 사용됩니다.
'shellslash'는 명령에서 슬래시를 사용합니다 (
MS-Windows 및 기타)
명령 출력을 파일에 기록하는 데 사용되는 'shellredir'문자열

유닉스에서 이것은 두 종류의 쉘이 있기 때문에 거의 문제가 되지 않습니다.
"sh"와 "csh"는 비슷합니다. Vim은 'shell'옵션을 확인하고 'shell'의 어딘가에 'csh'가 있는지 여부에 따라 관련 옵션을 자동으로 설정합니다.
그러나 MS-Windows에서는 여러 가지 쉘이 있으므로 필터링 작업을 수행하기 위해 옵션을 조정해야 할 수도 있습니다.
자세한 내용은 옵션에 대한 도움말을 확인하십시오.


READING COMMAND OUTPUT

현재 디렉토리의 내용을 파일로 읽으려면 다음을 사용하십시오.

유닉스에서 :>
: read! ls
MS-Windows에서 :>
: 읽기! dir

"ls"또는 "dir"명령의 출력이 캡쳐되어 텍스트 아래의 커서 아래에 삽입됩니다. 
이것은 파일 읽기와 유사하지만 "!" Vim에게 명령어가 뒤 따른다는 것을 알려주기 위해 사용된다. 
명령에 인수가 있을 수 있습니다. 
그리고 범위는 Vim이 어디에 있는지 알려주는 데 사용될 수 있습니다.
줄을 써야합니다 :>

: 0read! date -u

그러면 파일의 맨 위에 UTC 형식으로 현재 시간과 날짜가 삽입됩니다.
(글쎄, "- u"인수를 받아들이는 날짜 명령을 가지고 있다면). 
"!! date"를 사용하는 것의 차이점을 주목하십시오 : 
": read! date"가 라인을 삽입하는 동안 라인을 대체합니다.


문자 입력하기

Unix 명령 "wc"는 단어를 센다. 
현재 파일의 단어 수를 계산하려면 다음과 같이하십시오.>

: 쓰기! wc

이것은 이전과 같은 쓰기 명령이지만 파일 이름 대신 "!"
문자가 사용되며 외부 명령의 이름이 사용됩니다. 
작성된 텍스트는 지정된 명령으로 표준 입력으로 전달됩니다. 
결과는 다음과 같습니다.

       4 47 249 ~

"wc"명령은 자세한 정보가 아닙니다. 
즉 4 줄, 47 단어 및 249자를 의미합니다.

이 실수 조심해 :>

:쓰다! 화장실

강제로 현재 디렉토리에 "wc"라는 파일을 씁니다. 
공백이 중요합니다!


화면 다시 그리기

외부 명령이 오류 메시지를 생성하면 디스플레이가 엉망이되었을 수 있습니다. 
Vim은 매우 효율적이며 다시 그리기가 필요한 화면 부분만 다시 그립니다. 
하지만 다른 프로그램에 대해 알 수는 없습니다.
썼습니다. Vim에게 화면을 다시 그리게하려면 :>

CTRL-L

======================================================================================================================================================== ================

다음 장 : | usr_11.txt | 충돌에서 복구

저작권 : | manual-copyright | vim : tw = 78 : ts = 8 : ft
